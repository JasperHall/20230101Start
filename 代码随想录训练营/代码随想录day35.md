时间: 2023.6.13周二
<a name="sPFyY"></a>
# 今日任务
第八章 贪心算法 part04, 860.柠檬水找零, 406.根据身高重建队列, 452. 用最少数量的箭引爆气球 

<a name="CXkSh"></a>
# 收获
<a name="KOISD"></a>
# 明天计划

- [ ] 再看看 406.根据身高重建队列  和 452. 用最少数量的箭引爆气球 

<a name="XBsr0"></a>
# 复习

- [ ] 复习理解 134. 加油站 


<a name="Qm9R5"></a>
# 860.柠檬水找零 
:::info
本题看上好像挺难，其实挺简单的，大家先尝试自己做一做。<br />[代码随想录](https://programmercarl.com/0860.%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6.html)
:::
只需要维护三种金额的数量，5，10和20。<br />有如下三种情况：

- 情况一：账单是5，直接收下。
- 情况二：账单是10，消耗一个5，增加一个10
- 情况三：账单是20，优先消耗一个10和一个5，如果不够，再消耗三个5

此时大家就发现 情况一，情况二，都是固定策略，都不用我们来做分析了，而唯一不确定的其实在情况三。<br />而情况三逻辑也不复杂甚至感觉纯模拟就可以了，其实**情况三这里是有贪心的**。<br />账单是20的情况，为什么要优先消耗一个10和一个5呢？因为美元10只能给账单20找零，而美元5可以给账单10和账单20找零，美元5更万能！<br />所以**局部最优**：遇到账单20，优先消耗美元10，完成本次找零。**全局最优**：完成全部账单的找零。<br />局部最优可以推出全局最优，并找不出反例，那么就试试贪心算法！
```java
class Solution {
    public boolean lemonadeChange(int[] bills) {
        int five = 0;
        int ten = 0;

        for (int i = 0; i < bills.length; i++) {
            if (bills[i] == 5) {
                five++;
            } else if (bills[i] == 10) {
                five--;
                ten++;
            } else if (bills[i] == 20) {
                if (ten > 0) {
                    ten--;
                    five--;
                } else {
                    five -= 3;
                }
            }
            if (five < 0 || ten < 0) return false;
        }
        
        return true;
    }
}


时间复杂度: O(n)
空间复杂度: O(1)
```
-
<a name="PzYC9"></a>
# 406.根据身高重建队列 
:::info
本题有点难度，和分发糖果类似，不要两头兼顾，处理好一边再处理另一边。 <br />[代码随想录](https://programmercarl.com/0406.%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97.html)
:::
和 135.分发糖果 类似，不要两头兼顾，处理好一边再处理另一边。 <br />对于本题大家困惑的点肯定是先确定k还是先确定h呢? 也就是究竟先按 h 排序呢，还是先按照 k 排序呢？<br />如果按照k来从小到大排序，排完之后，会发现k的排列并不符合条件，身高也不符合条件，两个维度哪一个都没确定下来。<br />那么按照身高h来排序呢，身高一定是从大到小排（身高相同的话则k小的站前面），让高个子在前面。<br />此时我们可以确定一个维度了，就是**身高**，前面的节点一定都比本节点高！那么只需要按照 k 为下标重新插入队列就可以了，为什么呢？<br />以图中{5,2} 为例：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/32832913/1688055985062-a6159d01-c17d-4d46-9c12-0c5eb95decd2.png#averageHue=%23f8f3f3&clientId=ud8154408-c430-4&from=paste&height=315&id=u80dc9e09&originHeight=369&originWidth=824&originalType=binary&ratio=1.1699999570846558&rotation=0&showTitle=false&size=102747&status=done&style=none&taskId=ufe7962c1-7473-477e-b373-5b3b8c8ae1a&title=&width=704.2735301061034)<br />按照身高排序之后，优先按身高 大的 people 的 k 来插入，后序插入节点也不会影响前面已经插入的节点，最终按照 k 的规则完成了队列。<br />所以在按照身高从大到小排序后：

- 局部最优：优先按身高 大的 people 的 k 来插入。插入操作过后的 people 满足队列属性
- 全局最优：最后都做完插入操作，整个队列满足题目队列属性

局部最优可推出全局最优，找不出反例，那就试试贪心。
> 一些同学可能也会疑惑，你怎么知道局部最优就可以推出全局最优呢？ 有数学证明么？
> 在贪心系列开篇词[关于贪心算法，你该了解这些！](https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)中，已经讲过了这个问题了。
> 刷题或者面试的时候，手动模拟一下感觉可以局部最优推出整体最优，而且想不到反例，那么就试一试贪心，至于严格的数学证明，就不在讨论范围内了。

回归本题，整个插入过程如下：<br />排序完的 people： [[7,0], [7,1], [6,1], [5,0], [5,2]，[4,4]]<br />插入的过程：

1. 插入[7,0]：[[7,0]]
2. 插入[7,1]：[[7,0],[7,1]]
3. 插入[6,1]：[[7,0],[6,1],[7,1]]
4. 插入[5,0]：[[5,0],[7,0],[6,1],[7,1]]
5. 插入[5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]]
6. 插入[4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]

此时就按照题目的要求完成了重新排列。
```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        // 身高从大到小排（身高相同k小的站前面）
        Arrays.sort(people, (a, b) -> {
            if (a[0] == b[0]) return a[1] - b[1];   // a - b 是升序排列，故在a[0] == b[0]的狀況下，会根据k值升序排列
            return b[0] - a[0];  //b - a 是降序排列，在a[0] != b[0]，的状况会根据h值降序排列
        });

        LinkedList<int[]> que = new LinkedList<>();

        for (int[] p : people) {
            que.add(p[1],p);   //Linkedlist.add(index, value)，會將value插入到指定index裡。
        }

        return que.toArray(new int[people.length][]);  // 注意这里数组创建和转换的方法
    }
}
```
:::danger

1. 注意这个代码中排序的方法
2. 注意LinkedList的使用
3. `Linkedlist.add(index, value`)，会將value插入到指定index。
4. 注意最后转为数组的方法
:::
-
<a name="sbyHA"></a>
# 452. 用最少数量的箭引爆气球  
:::info
本题是一道 重叠区间的题目，好好做一做，因为明天三道题目，都是 重叠区间。 [代码随想录](https://programmercarl.com/0452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.html)
:::
本题是一道 重叠区间的题目<br />可以看出射击重叠最多的气球用的弓箭最少<br />尝试一下贪心: <br />**局部最优**：当气球出现重叠，一起射，所用弓箭最少。**全局最优**：把所有气球射爆所用弓箭最少。<br />如果真实的模拟射气球的过程，应该射一个，气球数组就 remove一个元素，这样最直观，毕竟气球被射了。但仔细思考一下就发现：如果把气球排序之后，从前到后遍历气球，被射过的气球仅仅跳过就行了，没有必要让气球数组 remove气球，只要记录一下箭的数量就可以了。以上为思考过程，已经确定下来使用贪心了，那么开始解题。<br />为了让气球尽可能的重叠，需要对数组进行排序。那么按照气球起始位置排序，还是按照气球终止位置排序呢？其实都可以！只不过对应的遍历顺序不同，我就按照气球的**起始位置**排序了。<br />既然按照起始位置排序，那么就**从前向后遍历气球数组**，靠左尽可能让气球重复。<br />从前向后遍历遇到重叠的气球了怎么办？如果气球重叠了，重叠气球中**右边**边界的最小值 之前的区间一定需要一个弓箭。<br />以题目示例： [[10,16],[2,8],[1,6],[7,12]]为例，如图：（方便起见，已经排序）<br />![20201123101929791.png](https://cdn.nlark.com/yuque/0/2023/png/32832913/1688986455040-dab80ed9-9dd0-4073-8746-182e0db8caab.png#averageHue=%23faf9f8&clientId=uaac7712e-4126-4&from=paste&height=438&id=u748b1e83&originHeight=512&originWidth=812&originalType=binary&ratio=1.1699999570846558&rotation=0&showTitle=false&size=64447&status=done&style=none&taskId=u72a4bb94-f35b-42ca-98f1-714323a9ab5&title=&width=694.0171194734902)<br />可以看出首先第一组重叠气球，一定是需要一个箭，**气球3的左边界大于了 第一组重叠气球的最小右边界，所以再需要一支箭来射气球3了**。
```java
/**
 * 时间复杂度 : O(NlogN)  排序需要 O(NlogN) 的复杂度
 * 空间复杂度 : O(logN) java所使用的内置函数用的是快速排序需要 logN 的空间
 */
class Solution {
    public int findMinArrowShots(int[][] points) {

        if (points.length == 0) return 0;

        // 根据气球直径的开始坐标从小到大排序
        // 使用Integer内置比较方法，不会溢出
        Arrays.sort(points, (a,b) -> Integer.compare(a[0], b[0]));

        int count = 1;  // points 不为空至少需要一支箭

        for (int i=1; i< points.length; i++){
            if (points[i][0] > points[i-1][1]){  // 气球i 和 气球i-1 不挨着，注意这里不是 >=
                count++;  // 需要加一只剑
            } else {  // 气球i和气球i-1挨着
                points[i][1] = Math.min(points[i][1], points[i-1][1]);   // 更新重叠气球 最小 右边界
            }
        }
        return count;
    }
}
```
:::danger
注意事项: 

1. 注意题目中说的是：满足 `xstart ≤ x ≤ xend`, 则该气球会被引爆。那么说明两个气球挨在一起不重叠也可以一起射爆, 所以代码中`if (points[i][0] > points[i - 1][1])`不能是`>=`
2. Integer的内置比较方法的使用
:::
这道题目贪心的思路很简单也很直接，就是重复的一起射了，但本题我认为是有难度的。就算思路都想好了，模拟射气球的过程，很多同学真的要去模拟了，实时把气球从数组中移走，这么写的话就复杂了。而且寻找重复的气球，寻找重叠气球最小右边界，其实都有代码技巧。<br />贪心题目有时候就是这样，看起来很简单，思路很直接，但是一写代码就感觉贼复杂无从下手。这里其实是需要代码功底的，那代码功底怎么练？<br />多看多写多总结!!!



